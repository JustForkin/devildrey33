<!-- 
    Test para el banner 3d de devildrey33.es creado por Josep Antoni Bover Comas el 31-07-2016
        - Consiste en un cuadrado de 7x7 cubos que se coordinan para realizar varios movimientos distintos.
	- Se utiliza JQuery y Three.js

	Vista por defecto en el Laboratorio de pruebas  
		devildrey33_Lab->Opciones->Vista = Preview;

        Ultima modificación el 03/08/2016
-->
<!DOCTYPE html>
<html>
    <head>
        <!-- Estilos CSS -->
<style type="text/css">
body { margin:0px; padding:0px; }
            
/* Estilos para los marcos informativos */
.Blog > #Cabecera {
    margin:0px;
    height:100%;
    border-top:none;
    color:#FFFFFF;
    background:rgba(49,46,53, 1);
    z-index:10;
    position:absolute;
    width:100%;
    overflow:hidden;
}        

.Blog > #Cabecera > #Cabecera_Canvas {
    width:100%;
    height:100%;
}
            
.Blog > #Cabecera > #Cabecera_Cargando,
.Blog > #Cabecera > #Cabecera_Stats {
    transition:0.3s cubic-bezier(.33,.05,.69,1.59);
    z-index:13;
    padding:10px;
    margin:5px;    
    background-color: rgba(37,35,40, 0.6);
    color:#FFF;
    text-shadow:1px 1px 1px #000;
    position:absolute;
    border:1px solid #353338;
}

.Blog > #Cabecera > #Cabecera_Cargando {
    top:0px;
    left:50%;
    transform:perspective(600px) rotateX(-90deg) translateX(-50%);
}        
            
.Blog > #Cabecera > #Cabecera_Stats {
    transform-origin: top center;
    transform:perspective(600px) rotateX(-90deg);  
    right:0px;
}
         
/* Solo se muestra la información de la animación si la animación está activa (puede estar visible pero inactiva si la web no tiene el foco) */
.Blog > #Cabecera[animar=true]:hover > #Cabecera_Stats {
    transform:perspective(600px) rotateX(0deg);    
}
/* Solo se muestra el texto cargando mientras el atributo cargando sea true (necesario para advertir de la carga de texturas) */
.Blog > #Cabecera[cargando=true] > #Cabecera_Cargando {
    transform:perspective(600px) rotateX(0deg) translateX(-50%);        
}

</style>
        
        <!-- Si deseas utilizar JQuery descomenta la siguiente línea -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>

        <!-- Si deseas utilizar Three 3D lib descomenta la siguiente línea -->
        <script src="/Web/JS/3rdParty/three-0.79.min.js"></script>

        <!-- Código javascript --> 
<script type="text/javascript">
    
/* Función para generar un valor aleatório entero */
/* Si no se especifican parametros devuelve 0 o 1 */
/* Si solo se especifica un parámetro, el primer parámetro será el máximo, y el mínimo será 0 */
/* Si se especifican dos parámetros, el primero es el máximo, y el segundo es el mínimo. */
function RandInt(Max, Min) {
    return Math.floor(Rand(Max, Min));
}


/* Si no se especifican parametros devuelve 0 o 1 
   Si se especifica solo el Máximo, el mínimo será 0 */
function Rand(Max, Min) {
    var min = (typeof(Min) !== "undefined") ? Min : 0; // Si no se especifica el mínimo por defecto es 0
    var max = (typeof(Max) !== "undefined") ? Max : 1; // Si no se especifica el máximo por defecto es 1
    return min + Math.random() * (max - min);    
}
    
    
AdiestramientoCubos = function(Tipo) {
    this.Canvas = document.getElementById("Cabecera_Canvas");

    // Asigno el estado cargando, que muestra una ventana que avisa al usuario.
    $("#Cabecera").attr({ "cargando" : true, "animar" : true });
    
    try {
        this.Context = new THREE.WebGLRenderer({ canvas : this.Canvas, "antialias" : true });    // Contexto THREE.JS
        this.Context.setClearColor(0x312E35, 1);    // Color del fondo
    }
    catch ( error ) {
        alert(error, "Error creando el Banner");
    }

    this.Ancho          = 0;                                                // Ancho del canvas
    this.Alto           = 0;                                                // Altura del canvas
    this.RAFID          = 0;                                                // Request Animation Frame ID
    this.FPS_UltimoTick = Date.now() + 1000;                                // Ultimo Tick del sistema + 1000ms
    this.FPS_Contador   = 0;                                                // Contador de frames por segundo    
    this.FocoWeb        = false;                                            // Foco de la ventana de la web
    
    
    $("#Cabecera").on("mousemove", function(event) { 
        if ($Banner !== null) {
            $Banner.EventoMouseMove(event.clientX, event.clientY);
        }
    });    
    
    // Función que determina el estado de carga (cargando/completo) true/false
    this.Cargando = function(carga) {
        $("#Cabecera").attr({ "cargando" : carga });
    };

    this.Actualizar = function() {
        if ($Banner !== null) {
            $Banner.FPS(); 
            $Banner.RAFID = window.requestAnimationFrame($Banner.Actualizar);
            $Banner.Pintar(); 
        }
    };

    // Función que procesa el evento mousemove
    this.EventoMouseMove = function(X, Y) {
        if (typeof(this.MouseMove) !== "undefined") {
            this.MouseMove.apply(this, [X, Y]);
        }
    };

    // Función que obtiene el tamaño del canvas una vez redimensionado.
    this.EventoRedimensionar = function() {
        /* El ancho del canvas siempre tiene que ser el mismo que #MarcoNavegacion - 60 pixeles que ocupan los botones de la izquierda
         * La altura del canvas siempre es la misma desde el principio */
        this.Ancho  = document.getElementById("Cabecera").offsetWidth; 
        this.Alto   = document.getElementById("Cabecera").offsetHeight;
        this.Context.setSize(this.Ancho, this.Alto);
        if (this.Camara !== null && typeof(this.Camara) !== 'undefined') { // Si hay una camara creada
            this.Camara.aspect = this.Ancho / this.Alto;
            this.Camara.updateProjectionMatrix();            
        }
    };
    
    
    // Función que cuenta los frames por segundo
    this.FPS = function() {
        var Tick = Date.now();
        if (Tick > this.FPS_UltimoTick) {
            this.FPS_UltimoTick = Tick + 1000;
            $("#Cabecera_Stats").html(this.FPS_Contador + " FPS");
            this.FPS_Contador = 0;
        }
        else {
            this.FPS_Contador ++;
        }
    };
    ////////////////////////////////////////////////////////////////////////////////////////////  
    
    // Función que inicia los parámetros para este baner concreto
    this.IniciarBanner = function() {
        this.TamCubo        = 0; // Tamaño de cada cubo

        this.Escena = new THREE.Scene();
        this.Camara = new THREE.PerspectiveCamera(40, this.Ancho / this.Alto, 0.5, 10000);
        // Preparo la camara
        this.Camara.position.set( 0, 0, 2500 );
        this.Escena.add(this.Camara);
        // Colores base que se van alternando
    //    this.RGBF = [ 50, 0, 0, 0 ]; // RGB que incluye la fase en el ultimo valor (0=R, 1=G, 2=B);

        this.TipoAni = 0;
        this.CharAni = 0;
        
        this.RotacionCam = Rand(0.002, -0.002);
        this.AvanceCamZ  = -0.1;
        
        // Variables locales
        var Divisiones  = 7;       // Numero de columnas de un lado
        var Tam         = 1000;

        this.TamCubo = (Tam / (Divisiones / 2));
        this.YBase = (this.TamCubo / 2) + this.TamCubo;

        // Creo la parrilla
        this.Parrilla = new THREE.GridHelper(Tam, Divisiones, new THREE.Color(0xcccccc), new THREE.Color(0x999999));
        this.Parrilla.position.y = this.TamCubo;

        // Creo el grupo de columnas
        this.GrupoCubos = new THREE.Object3D();
        this.GrupoCubos.add(this.Parrilla);
        t = this.TamCubo * 0.7;
        var geometry = new THREE.BoxGeometry( t, t, t );    

        // Inicio cada columna en su posición
        for (var z = -(Divisiones / 2); z < (Divisiones / 2); z++) {
            for (var x = -(Divisiones / 2); x < (Divisiones / 2); x++) {

                var Grupo = new THREE.Object3D();
                var Cubo = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial( { color: "rgb(0,50,0)" /*, wireframe : true */} ));
                Grupo.Ani = new this.AniColumna(1, 1, 0);
                Grupo.add(Cubo);
                Grupo.position.set((x * this.TamCubo) + (this.TamCubo / 2), this.YBase, (z * this.TamCubo) + (this.TamCubo / 2));
                this.CrearMarcoCubo(Grupo, t);
                this.GrupoCubos.add(Grupo);
            }
        }

        this.RandAni();

        this.GrupoCubos.rotation.x = 0.55;        
        this.Escena.add(this.GrupoCubos);


        // create a point light
        var pointLight = new THREE.PointLight(0xFF0000);
        pointLight.position.set(0, 10, 0);
        // add to the scene
        this.Escena.add(pointLight);   

        this.Cargando(false);     
    };
    
    this.Pintar = function() {
        // posición de la camara, y rotación del grupo de objetos
        var rnd = Rand();
        if (rnd < 0.15) {
            rnd = RandInt(4);
            if (rnd === 0)      { if (this.RotacionCam > -0.004)    { this.RotacionCam -= 0.0003; }}
            else if (rnd === 1) { if (this.RotacionCam < 0.004)     { this.RotacionCam += 0.0003; }}
            else if (rnd === 2) { if (this.AvanceCamZ > -2)       { this.AvanceCamZ -= 0.1; }}
            else if (rnd === 3) { if (this.AvanceCamZ < 2)        { this.AvanceCamZ += 0.1; }}
        }
        // Rotación y
        this.GrupoCubos.rotation.y += this.RotacionCam;
        // Posición Z
        if ((this.Camara.position.z < 3800 && this.AvanceCamZ > 0) || (this.Camara.position.z > 2500 && this.AvanceCamZ < 0)) {
            this.Camara.position.z += this.AvanceCamZ;
        }
        
        var AniTerminada = true;
        for (var c = 1; c < this.GrupoCubos.children.length; c++) {
            var Cubo = this.GrupoCubos.children[c];
            
            if (Cubo.Ani.FaseAni === 0) {
                if (Cubo.Ani.Retardo < 0) { // En delay
                    Cubo.Ani.Retardo += 16; // (16 milisegundos que suele tardar un frame a 60 por segundo)
                }
                else {
                    if (Cubo.position.y < this.YBase + Cubo.Ani.MaxEscalaY) { 
                        Cubo.position.y += Cubo.Ani.Vel;
                    }
                    else {
                        Cubo.Ani.FaseAni = 1;
                    }
                }
            }
            else if (Cubo.Ani.FaseAni === 1) {
                if (Cubo.position.y > this.YBase) { 
                    Cubo.position.y -= Cubo.Ani.Vel;
                }
                else { // Se ha terminado una vuelta
                    Cubo.Ani.FaseAni = 2;
                }
            }            
            
            var col = Math.floor(50 + ((Cubo.position.y - this.YBase) * 0.5));
            
            Cubo.children[0].material.color.setStyle("rgb(180, " + col + ",0)");            
            
            // Compruebo si la columna ha terminado
            if (Cubo.Ani.FaseAni !== 2) { 
                AniTerminada = false; 
            }                                                
        }
        
        // La animación 4 termina una vez por letra
        if (this.TipoAni === 4 && AniTerminada === true) {
            var texto = "devildrey33";
            if (this.CharAni < texto.length - 1) {
                this.CharAni += 1;
                this.IniciarAni_Caracter(texto.substr(this.CharAni, 1));
                AniTerminada = false;
            }
            else {
                this.CharAni = 0;
            }
        }
        
     
        this.Context.render(this.Escena, this.Camara);
        
        if (AniTerminada === true) { 
            this.RandAni(); 
        }
    };
      
      
    this.CrearMarcoCubo = function(Objeto, Tam) {
        var Grupo = new THREE.Object3D();
        var Med = Tam / 2;
        var GeoX = new THREE.Geometry();
        var GeoY = new THREE.Geometry();
        var GeoZ = new THREE.Geometry();
        GeoX.vertices.push(new THREE.Vector3( -Med, 0, 0 ) );
        GeoX.vertices.push(new THREE.Vector3( Med, 0, 0 ) );
        GeoY.vertices.push(new THREE.Vector3( 0, -Med, 0 ) );
        GeoY.vertices.push(new THREE.Vector3( 0, Med, 0 ) );
        GeoZ.vertices.push(new THREE.Vector3( 0, 0, -Med  ) );
        GeoZ.vertices.push(new THREE.Vector3( 0, 0, Med ) );
        Grupo.Material = new THREE.LineBasicMaterial( { color: 0x333333, opacity: .2, linewidth: .1 } );
        // Frontal
        var Linea1 = new THREE.Line( GeoX, Grupo.Material );
        var Linea2 = new THREE.Line( GeoX, Grupo.Material );
        var Linea3 = new THREE.Line( GeoY, Grupo.Material );
        var Linea4 = new THREE.Line( GeoY, Grupo.Material );
        Linea1.position.set(0, -Med, Med);
        Linea2.position.set(0, Med, Med);
        Linea3.position.set(Med, 0, Med);
        Linea4.position.set(-Med, 0, Med);
        Grupo.add(Linea1);
        Grupo.add(Linea2);
        Grupo.add(Linea3);
        Grupo.add(Linea4);
        // Trasero
        var Linea5 = new THREE.Line( GeoX, Grupo.Material );
        var Linea6 = new THREE.Line( GeoX, Grupo.Material );
        var Linea7 = new THREE.Line( GeoY, Grupo.Material );
        var Linea8 = new THREE.Line( GeoY, Grupo.Material );
        Linea5.position.set(0, -Med, -Med);
        Linea6.position.set(0, Med, -Med);
        Linea7.position.set(Med, 0, -Med);
        Linea8.position.set(-Med, 0, -Med);
        Grupo.add(Linea5);
        Grupo.add(Linea6);
        Grupo.add(Linea7);
        Grupo.add(Linea8);
        // Superior (basta con 2 líneas)
        var Linea9 = new THREE.Line( GeoZ, Grupo.Material );
        var Linea10 = new THREE.Line( GeoZ, Grupo.Material );
        Linea9.position.set(-Med, Med, 0);
        Linea10.position.set(Med, Med, 0);
        Grupo.add(Linea9);
        Grupo.add(Linea10);
        // Inferior (basta con 2 líneas)
        var Linea11 = new THREE.Line( GeoZ, Grupo.Material );
        var Linea12 = new THREE.Line( GeoZ, Grupo.Material );
        Linea11.position.set(-Med, -Med, 0);
        Linea12.position.set(Med, -Med, 0);
        Grupo.add(Linea9);
        Grupo.add(Linea10);
        
        Objeto.add(Grupo);
    };
    // Inicia la animación de un caracter
    this.IniciarAni_Caracter = function(Char) {
//        console.log("Banner_AdiestramientoCubos3D", Char);
        var ColumnasLado = Math.sqrt(this.GrupoCubos.children.length - 1);
        var Inicio       = Math.floor((ColumnasLado - 5) / 2); // Las letras son de 5x5
        var cc = 0;
        for (var z = Inicio; z < ColumnasLado - Inicio; z++) {
            for (var x = Inicio; x < ColumnasLado - Inicio; x++) {
                var PosMarcador = 1 + ((z * ColumnasLado) + x);
                var PosLetra    = ((z - Inicio) * (ColumnasLado - (Inicio * 2))) + (x - Inicio);
                if (this.Letras5x5[Char][PosLetra] === "x") {
                    this.GrupoCubos.children[PosMarcador].Ani = new this.AniColumna(300, 20, 0);
                }
                else {                    
                    this.GrupoCubos.children[PosMarcador].Ani = new this.AniColumna(1, 1, 0);
                }
            }
        }
    };
    // Inicia la animación del texto caracter a caracter
    this.IniciarAni_Texto = function() {
        this.CharAni = 0;
        this.IniciarAni_Caracter('d');
    };
    // Filas invertidas para el eje X o el eje Z
    this.IniciarAni_Filas = function() {
        var ColumnasLado = Math.sqrt(this.GrupoCubos.children.length - 1);
        var Invertir = false;
        var rnd = Rand();
        for (var z = 0; z < ColumnasLado; z++) {
            Invertir = !Invertir;
            for (var x = 0; x < ColumnasLado; x++) {
                var Pos = 1 + ((rnd > 0.5) ? ((z * ColumnasLado) + x) : ((x * ColumnasLado) + z));
                this.GrupoCubos.children[Pos].Ani = new this.AniColumna(300, 15, ((Invertir === true)? x * 80 : (ColumnasLado - x) * 80));
            }
        }
    }; 
    // Aleatório
    this.IniciarAni_Rand = function() {
        for (var c = 1; c < this.GrupoCubos.children.length; c++) {
            this.GrupoCubos.children[c].Ani = new this.AniColumna(Rand(300, 100), Rand(15, 20), RandInt(500));
        }
    };
    // Ola de izquierda a derecha, o derecha a izquierda, o de arriba a abajo, o de abajo a arriba
    this.IniciarAni_Ola = function() {
        var rnd = Rand();        
        var rnd2 = Rand();
        var ColumnasLado = Math.sqrt(this.GrupoCubos.children.length - 1);
        var pos = 0;
        for (var z = 0; z < ColumnasLado; z++) {
            for (var x = 0; x < ColumnasLado; x++, pos++) {
                var Pos = 1 + ((rnd2 > 0.5) ? ((z * ColumnasLado) + x) : ((x * ColumnasLado) + z));                
                this.GrupoCubos.children[Pos].Ani = new this.AniColumna(Rand(300, 250), 15, ((rnd > 0.5) ? pos * 20 : (this.GrupoCubos.children.length - pos) * 20) );
            }
        }
    };
    // Ola centrada en el eje X 
    this.IniciarAni_OlaCentrada = function() {
        var rnd = Rand();
        var ColumnasLado = Math.sqrt(this.GrupoCubos.children.length - 1);
        var Max = Math.floor((this.GrupoCubos.children.length - 1) / 2);
        this.GrupoCubos.children[this.GrupoCubos.children.length - 1].Ani =  new this.AniColumna(Rand(300, 250), 15, Max * 20);
        for (var c = 0; c < Max + 1; c++) { 
            this.GrupoCubos.children[(Max + c)].Ani = new this.AniColumna(Rand(300, 250), 15, c * 20);
            this.GrupoCubos.children[(Max - c) + 1].Ani = new this.AniColumna(Rand(300, 250), 15, c * 20);
        }            
    };
    
    // Inicia una animación aleatória
    this.RandAni = function() {        
        if (this.TipoAni !== 4) { this.TipoAni = RandInt(5); }
        else                    { this.TipoAni = RandInt(4); } // Evito la animación del texto, si es la ultima que se ha hecho

        if (this.TipoAni  === 0)       {   this.IniciarAni_Rand(); }
        else if (this.TipoAni  === 1)  {   this.IniciarAni_Ola(); }
        else if (this.TipoAni  === 2)  {   this.IniciarAni_OlaCentrada(); }
        else if (this.TipoAni  === 3)  {   this.IniciarAni_Filas(); }
        else if (this.TipoAni  === 4)  {   (Rand() > 0.2) ? this.RandAni() : this.IniciarAni_Texto(); } // la animación del texto que salga lo menos posible
    };
    
    // Estructura para guardar los valores de la animación
    this.AniColumna = function(nMaxEscalaY, nVel, nRetardo) {
        this.MaxEscalaY = nMaxEscalaY;
        this.Vel        = nVel;
        this.Retardo    = -nRetardo;
        this.FaseAni    = 0;            // 0 Animando, 1 Desanimando, 2 Terminado
    };
      
    this.Letras5x5 = { "d"  :  [    " ", "x", "x", " ", " ",
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", "x", " ", " " ],
                                        
                        "e" :  [    " ", "x", "x", "x", " ", 
                                    " ", "x", " ", " ", " ", 
                                    " ", "x", "x", " ", " ", 
                                    " ", "x", " ", " ", " ", 
                                    " ", "x", "x", "x", " " ],

                        "v" :  [    "x", " ", " ", " ", "x", 
                                    "x", " ", " ", " ", "x", 
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", " ", "x", " ", " " ],

                        "i" :  [    " ", "x", "x", "x", " ", 
                                    " ", " ", "x", " ", " ", 
                                    " ", " ", "x", " ", " ", 
                                    " ", " ", "x", " ", " ", 
                                    " ", "x", "x", "x", " " ],

                        "l" :  [    " ", "x", " ", " ", " ", 
                                    " ", "x", " ", " ", " ", 
                                    " ", "x", " ", " ", " ", 
                                    " ", "x", " ", " ", " ", 
                                    " ", "x", "x", "x", " " ],

                        "r" :  [    " ", "x", "x", " ", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", "x", " ", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", "x", " ", "x", " " ],

                        "y" :  [    " ", "x", " ", "x", " ", 
                                    " ", "x", " ", "x", " ", 
                                    " ", " ", "x", " ", " ", 
                                    " ", " ", "x", " ", " ", 
                                    " ", " ", "x", " ", " " ],

                        "3" :  [    " ", "x", "x", "x", " ", 
                                    " ", " ", " ", "x", " ", 
                                    " ", " ", "x", "x", " ", 
                                    " ", " ", " ", "x", " ", 
                                    " ", "x", "x", "x", " " ] }           
    this.EventoRedimensionar();
    this.IniciarBanner();
    this.RAFID = window.requestAnimationFrame(this.Actualizar);       

};

var $Banner = null;

$(window).on("load", function() { $Banner = new AdiestramientoCubos(); });


// Evento cambio de tamaño
$(window).on("resize", function() { 
    if ($Banner !== null) { $Banner.EventoRedimensionar(); }
});


// Evento posición scroll
$(window).on("scroll", function() { 
    if ($Banner !== null) { $Banner.EventoScroll(); }
});

</script>
    </head>
    <body>                
        <article class='Blog'>
            <header id='Cabecera'>
                <div id="Cabecera_Cargando">Cargando animación...</div>
                <div id='Cabecera_Stats'>60 FPS</div>
                <canvas id='Cabecera_Canvas'></canvas>
            </header>
        </article>
    </body>
</html>