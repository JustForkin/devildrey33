<div class='Codigo_Marco' id='IDPintar'><div class='Codigo_Titulo'>Archivo : ObjetoEscena_VentanaTranslucida.cpp</div><div class='Codigo_Numeracion'>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br></div><pre class='Codigo_PRECodigo'><div l=1><span class='TxtNegro'><span class='TxtVerde'>// Estructura que se usara para almacenar un pixel de un BMP</span></span></div><div l=2><span class='TxtNegro'><span class='TxtAzul'>struct</span> EstructuraBitmap32Bits {</span></div><div l=3><span class='TxtNegro'>    <span class='TxtAzul'>char</span> B;</span></div><div l=4><span class='TxtNegro'>    <span class='TxtAzul'>char</span> G;</span></div><div l=5><span class='TxtNegro'>    <span class='TxtAzul'>char</span> R;</span></div><div l=6><span class='TxtNegro'>    <span class='TxtAzul'>char</span> Valor;</span></div><div l=7><span class='TxtNegro'>};</span></div><div l=8><span class='TxtNegro'></span></div><div l=9><span class='TxtNegro'><span class='TxtVerde'>// Definicion que podemos modificar si necesitamos mas de 10 pixeles cuadrados para el escaneo de las puntas</span></span></div><div l=10><span class='TxtNegro'><span class='TxtAzul'>#define </span>ESPACIO_REDONDEADO 10</span></div><div l=11><span class='TxtNegro'></span></div><div l=12><span class='TxtNegro'><span class='TxtVerde'>// Función para pintar la ventana translucida</span></span></div><div l=13><span class='TxtNegro'><span class='TxtAzul'>void</span> ObjetoEscena_VentanaTranslucida::Pintar(HDC hDCDestino) {</span></div><div l=14><span class='TxtNegro'>    <span class='TxtVerde'>// Si no es visible salimos</span></span></div><div l=15><span class='TxtNegro'>    <span class='TxtAzul'>if</span> (Visible == FALSE) <span class='TxtAzul'>return</span>;</span></div><div l=16><span class='TxtNegro'></span></div><div l=17><span class='TxtNegro'>    <span class='TxtVerde'>// Espacio para nuestro buffer</span></span></div><div l=18><span class='TxtNegro'>    RECT    RC              = { <span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, Espacio.right - Espacio.left, Espacio.bottom - Espacio.top };</span></div><div l=19><span class='TxtNegro'>    </span></div><div l=20><span class='TxtNegro'>    <span class='TxtVerde'>// Creo un buffer para el fondo</span></span></div><div l=21><span class='TxtNegro'>    HDC     BufferFondo     = CreateCompatibleDC(hDCDestino);</span></div><div l=22><span class='TxtNegro'>    HBITMAP BmpFondo        = CreateCompatibleBitmap(hDCDestino, RC.right, RC.bottom);</span></div><div l=23><span class='TxtNegro'>    HBITMAP ViejoFondo      = <span class='TxtAzul'>static_cast</span>&lt;HBITMAP&gt;(SelectObject(BufferFondo, BmpFondo));</span></div><div l=24><span class='TxtNegro'>    SetBkColor(BufferFondo, EscenaPadre-&gt;ColorFondo);</span></div><div l=25><span class='TxtNegro'></span></div><div l=26><span class='TxtNegro'>    <span class='TxtVerde'>// Creo un buffer para la ventana translucida</span></span></div><div l=27><span class='TxtNegro'>    HDC     BufferVentana   = CreateCompatibleDC(hDCDestino);</span></div><div l=28><span class='TxtNegro'>    HBITMAP BmpVentana      = CreateCompatibleBitmap(hDCDestino, RC.right, RC.bottom);</span></div><div l=29><span class='TxtNegro'>    HBITMAP ViejoVentana    = <span class='TxtAzul'>static_cast</span>&lt;HBITMAP&gt;(SelectObject(BufferVentana, BmpVentana));</span></div><div l=30><span class='TxtNegro'>    SetBkColor(BufferVentana, EscenaPadre-&gt;ColorFondo);</span></div><div l=31><span class='TxtNegro'></span></div><div l=32><span class='TxtNegro'>    <span class='TxtVerde'>// Creo una region para usarla en la ventana translucida</span></span></div><div l=33><span class='TxtNegro'>    HRGN    Region          = CreateRoundRectRgn(<span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, RC.right + <span class='TxtRojo'>1</span>, RC.bottom + <span class='TxtRojo'>1</span>, <span class='TxtRojo'>20</span>, <span class='TxtRojo'>20</span>);</span></div><div l=34><span class='TxtNegro'>    </span></div><div l=35><span class='TxtNegro'>    <span class='TxtVerde'>// Pinto el fondo del hDCDestino en el buffer</span></span></div><div l=36><span class='TxtNegro'>    BitBlt(BufferFondo, <span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, RC.right, RC.bottom, hDCDestino, Espacio.left, Espacio.top, SRCCOPY);</span></div><div l=37><span class='TxtNegro'></span></div><div l=38><span class='TxtNegro'>    <span class='TxtVerde'>// Pinto fondo de la ventana padre</span></span></div><div l=39><span class='TxtNegro'>    FillRect(BufferVentana, &RC, <span class='TxtAzul'>static_cast</span>&lt;HBRUSH&gt;(GetStockObject(BLACK_BRUSH)));</span></div><div l=40><span class='TxtNegro'></span></div><div l=41><span class='TxtNegro'>    <span class='TxtVerde'>// Pinto el fondo de esta ventana</span></span></div><div l=42><span class='TxtNegro'>    HBRUSH Brocha = CreateSolidBrush(ColorFondo);</span></div><div l=43><span class='TxtNegro'>    FillRgn(BufferVentana, Region, Brocha);</span></div><div l=44><span class='TxtNegro'>    DeleteObject(Brocha);</span></div><div l=45><span class='TxtNegro'></span></div><div l=46><span class='TxtNegro'>    <span class='TxtVerde'>// Pinto el borde de esta ventana</span></span></div><div l=47><span class='TxtNegro'>    Brocha = CreateSolidBrush(ColorBordeI);</span></div><div l=48><span class='TxtNegro'>    FrameRgn(BufferVentana, Region, Brocha, <span class='TxtRojo'>2</span>, <span class='TxtRojo'>2</span>);</span></div><div l=49><span class='TxtNegro'>    DeleteObject(Brocha);</span></div><div l=50><span class='TxtNegro'>    Brocha = CreateSolidBrush(ColorBordeE);</span></div><div l=51><span class='TxtNegro'>    FrameRgn(BufferVentana, Region, Brocha, <span class='TxtRojo'>1</span>, <span class='TxtRojo'>1</span>);</span></div><div l=52><span class='TxtNegro'>    DeleteObject(Brocha);</span></div><div l=53><span class='TxtNegro'>    </span></div><div l=54><span class='TxtNegro'>    <span class='TxtVerde'>// Pintamos los graficos extras de las ventanas que hereden de esta clase</span></span></div><div l=55><span class='TxtNegro'>    Pintar_AlphaBlend(BufferVentana);</span></div><div l=56><span class='TxtNegro'>    </span></div><div l=57><span class='TxtNegro'>    <span class='TxtVerde'>// Pinto la ventana encima del fondo de forma translucida</span></span></div><div l=58><span class='TxtNegro'>    BLENDFUNCTION BF;</span></div><div l=59><span class='TxtNegro'>    BF.AlphaFormat         = <span class='TxtRojo'>0</span>;</span></div><div l=60><span class='TxtNegro'>    BF.BlendOp             = AC_SRC_OVER;</span></div><div l=61><span class='TxtNegro'>    BF.BlendFlags          = NULL;</span></div><div l=62><span class='TxtNegro'>    BF.SourceConstantAlpha = <span class='TxtRojo'>200</span>;</span></div><div l=63><span class='TxtNegro'>    BOOL A = AlphaBlend(BufferFondo, <span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, RC.right, RC.bottom, BufferVentana, <span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, RC.right, RC.bottom, BF);</span></div><div l=64><span class='TxtNegro'></span></div><div l=65><span class='TxtNegro'>    <span class='TxtVerde'>// Rellenamos la estructura BITMAPINFOHEADER para poder obtener los datos del BMP</span></span></div><div l=66><span class='TxtNegro'>    BITMAPINFOHEADER   bi;    </span></div><div l=67><span class='TxtNegro'>    bi.biSize          = <span class='TxtAzul'>sizeof</span>(BITMAPINFOHEADER);    </span></div><div l=68><span class='TxtNegro'>    bi.biWidth         = RC.right;    </span></div><div l=69><span class='TxtNegro'>    bi.biHeight        = RC.bottom;  </span></div><div l=70><span class='TxtNegro'>    bi.biPlanes        = <span class='TxtRojo'>1</span>;    </span></div><div l=71><span class='TxtNegro'>    bi.biBitCount      = <span class='TxtRojo'>32</span>;                        <span class='TxtVerde'>// Debe ser 32 para que la alineacion sea 8B+8G+8R+8BitImagen</span></span></div><div l=72><span class='TxtNegro'>    bi.biCompression   = BI_RGB;    </span></div><div l=73><span class='TxtNegro'>    bi.biSizeImage     = (RC.right * RC.bottom) * <span class='TxtRojo'>4</span>;  </span></div><div l=74><span class='TxtNegro'>    bi.biXPelsPerMeter = <span class='TxtRojo'>0</span>;    </span></div><div l=75><span class='TxtNegro'>    bi.biYPelsPerMeter = <span class='TxtRojo'>0</span>;    </span></div><div l=76><span class='TxtNegro'>    bi.biClrUsed       = <span class='TxtRojo'>0</span>;    </span></div><div l=77><span class='TxtNegro'>    bi.biClrImportant  = <span class='TxtRojo'>0</span>;</span></div><div l=78><span class='TxtNegro'></span></div><div l=79><span class='TxtNegro'>    LONG nx, ny, nxy;</span></div><div l=80><span class='TxtNegro'>    nxy = <span class='TxtRojo'>0</span>;</span></div><div l=81><span class='TxtNegro'></span></div><div l=82><span class='TxtNegro'>    <span class='TxtVerde'>// El siguiente código se ha optimizado para obtener la maxima velocidad</span></span></div><div l=83><span class='TxtNegro'>    <span class='TxtVerde'>// Inicialmente se escaneaban todos los pixels y se miraba si estaban dentro de la region con PtInRgn.</span></span></div><div l=84><span class='TxtNegro'>    <span class='TxtVerde'>// Pero de esa forma si la region tiene 1000*1000 pixeles estamos haciendo un millon de iteraciones cuando con unas 400 bastaria</span></span></div><div l=85><span class='TxtNegro'>    <span class='TxtVerde'>// Para solucionar esto escanearemos 10 pixeles cuadrados por cada punta del rectangulo.</span></span></div><div l=86><span class='TxtNegro'>    <span class='TxtVerde'>// La efectividad de esta optimización se nota en la función Pintar_Escena la cual tardaba 32ms, y ahora tarda de 0 a 1ms</span></span></div><div l=87><span class='TxtNegro'>    EstructuraBitmap32Bits *Bmp = <span class='TxtAzul'>new</span> EstructuraBitmap32Bits[RC.right * RC.bottom];</span></div><div l=88><span class='TxtNegro'></span></div><div l=89><span class='TxtNegro'>    GetDIBits(BufferFondo, BmpFondo, <span class='TxtRojo'>0</span>, (UINT)RC.bottom, Bmp, (BITMAPINFO *)&bi, DIB_RGB_COLORS);</span></div><div l=90><span class='TxtNegro'>    <span class='TxtVerde'>// Punta 7 (del teclado numerico)</span></span></div><div l=91><span class='TxtNegro'>    <span class='TxtAzul'>for</span> (ny = <span class='TxtRojo'>0</span>; ny &lt; ESPACIO_REDONDEADO; ny ++) {</span></div><div l=92><span class='TxtNegro'>        <span class='TxtAzul'>for</span> (nx = <span class='TxtRojo'>0</span>; nx &lt; ESPACIO_REDONDEADO; nx ++) {</span></div><div l=93><span class='TxtNegro'>            <span class='TxtAzul'>if</span> (PtInRegion(Region, nx, ny) == FALSE) {</span></div><div l=94><span class='TxtNegro'>                nxy = (ny * RC.right) + nx;</span></div><div l=95><span class='TxtNegro'>                Bmp[nxy].R = COLOR_TRANSPARENTE_R;</span></div><div l=96><span class='TxtNegro'>                Bmp[nxy].G = COLOR_TRANSPARENTE_G;</span></div><div l=97><span class='TxtNegro'>                Bmp[nxy].B = COLOR_TRANSPARENTE_B;</span></div><div l=98><span class='TxtNegro'>            }</span></div><div l=99><span class='TxtNegro'>        }</span></div><div l=100><span class='TxtNegro'>    }</span></div><div l=101><span class='TxtNegro'>    <span class='TxtVerde'>// Punta 9 (del teclado numerico)</span></span></div><div l=102><span class='TxtNegro'>    <span class='TxtAzul'>for</span> (ny = <span class='TxtRojo'>0</span>; ny &lt; ESPACIO_REDONDEADO; ny ++) { </span></div><div l=103><span class='TxtNegro'>        <span class='TxtAzul'>for</span> (nx = RC.right - ESPACIO_REDONDEADO; nx &lt; RC.right; nx ++) {</span></div><div l=104><span class='TxtNegro'>            <span class='TxtAzul'>if</span> (PtInRegion(Region, nx, ny) == FALSE) {</span></div><div l=105><span class='TxtNegro'>                nxy = (ny * RC.right) + nx;</span></div><div l=106><span class='TxtNegro'>                Bmp[nxy].R = COLOR_TRANSPARENTE_R;</span></div><div l=107><span class='TxtNegro'>                Bmp[nxy].G = COLOR_TRANSPARENTE_G;</span></div><div l=108><span class='TxtNegro'>                Bmp[nxy].B = COLOR_TRANSPARENTE_B;</span></div><div l=109><span class='TxtNegro'>            }</span></div><div l=110><span class='TxtNegro'>        }</span></div><div l=111><span class='TxtNegro'>    }</span></div><div l=112><span class='TxtNegro'>    <span class='TxtVerde'>// Punta 1 (del teclado numerico)</span></span></div><div l=113><span class='TxtNegro'>    <span class='TxtAzul'>for</span> (ny = RC.bottom - ESPACIO_REDONDEADO; ny &lt; RC.bottom; ny ++) { </span></div><div l=114><span class='TxtNegro'>        <span class='TxtAzul'>for</span> (nx = <span class='TxtRojo'>0</span>; nx &lt; ESPACIO_REDONDEADO; nx ++) {</span></div><div l=115><span class='TxtNegro'>            <span class='TxtAzul'>if</span> (PtInRegion(Region, nx, ny) == FALSE) {</span></div><div l=116><span class='TxtNegro'>                nxy = (ny * RC.right) + nx;</span></div><div l=117><span class='TxtNegro'>                Bmp[nxy].R = COLOR_TRANSPARENTE_R;</span></div><div l=118><span class='TxtNegro'>                Bmp[nxy].G = COLOR_TRANSPARENTE_G;</span></div><div l=119><span class='TxtNegro'>                Bmp[nxy].B = COLOR_TRANSPARENTE_B;</span></div><div l=120><span class='TxtNegro'>            }</span></div><div l=121><span class='TxtNegro'>        }</span></div><div l=122><span class='TxtNegro'>    }</span></div><div l=123><span class='TxtNegro'>    <span class='TxtVerde'>// Punta 3 (del teclado numerico)</span></span></div><div l=124><span class='TxtNegro'>    <span class='TxtAzul'>for</span> (ny = RC.bottom - ESPACIO_REDONDEADO; ny &lt; RC.bottom; ny ++) {</span></div><div l=125><span class='TxtNegro'>        <span class='TxtAzul'>for</span> (nx = RC.right - ESPACIO_REDONDEADO; nx &lt; RC.right; nx ++) {</span></div><div l=126><span class='TxtNegro'>            <span class='TxtAzul'>if</span> (PtInRegion(Region, nx, ny) == FALSE) {</span></div><div l=127><span class='TxtNegro'>                nxy = (ny * RC.right) + nx;</span></div><div l=128><span class='TxtNegro'>                Bmp[nxy].R = COLOR_TRANSPARENTE_R;</span></div><div l=129><span class='TxtNegro'>                Bmp[nxy].G = COLOR_TRANSPARENTE_G;</span></div><div l=130><span class='TxtNegro'>                Bmp[nxy].B = COLOR_TRANSPARENTE_B;</span></div><div l=131><span class='TxtNegro'>            }</span></div><div l=132><span class='TxtNegro'>        }</span></div><div l=133><span class='TxtNegro'>    }</span></div><div l=134><span class='TxtNegro'></span></div><div l=135><span class='TxtNegro'>    <span class='TxtVerde'>// Asignamos el nuevo BMP al HDC que hace de buffer</span></span></div><div l=136><span class='TxtNegro'>    SetDIBits(BufferFondo, BmpFondo, <span class='TxtRojo'>0</span>, (UINT)RC.bottom, Bmp, (BITMAPINFO *)&bi, DIB_RGB_COLORS);</span></div><div l=137><span class='TxtNegro'></span></div><div l=138><span class='TxtNegro'>    <span class='TxtVerde'>// Borramos los datos del Bmp de memoria</span></span></div><div l=139><span class='TxtNegro'>    <span class='TxtAzul'>delete</span> Bmp;</span></div><div l=140><span class='TxtNegro'></span></div><div l=141><span class='TxtNegro'>    <span class='TxtVerde'>// Llamamos a la funcion Pintar_Terminado para pintar aquellos graficos que no queramos incluir con AlphaBlend</span></span></div><div l=142><span class='TxtNegro'>    Pintar_Terminado(BufferFondo);</span></div><div l=143><span class='TxtNegro'></span></div><div l=144><span class='TxtNegro'>    <span class='TxtVerde'>// Pintamos el Bitmap con las puntas transparentes</span></span></div><div l=145><span class='TxtNegro'>    TransparentBlt( hDCDestino, Espacio.left, Espacio.top, Espacio.right - Espacio.left, Espacio.bottom - Espacio.top,</span></div><div l=146><span class='TxtNegro'>                    BufferFondo, <span class='TxtRojo'>0</span>, <span class='TxtRojo'>0</span>, RC.right, RC.bottom, RGB(COLOR_TRANSPARENTE_R, COLOR_TRANSPARENTE_G, COLOR_TRANSPARENTE_B) );</span></div><div l=147><span class='TxtNegro'></span></div><div l=148><span class='TxtNegro'>    <span class='TxtVerde'>// Elimino la region de la memoria</span></span></div><div l=149><span class='TxtNegro'>    DeleteObject(Region);</span></div><div l=150><span class='TxtNegro'></span></div><div l=151><span class='TxtNegro'>    <span class='TxtVerde'>// Elimino buffers de la memoria</span></span></div><div l=152><span class='TxtNegro'>    SelectObject(BufferFondo, ViejoFondo);</span></div><div l=153><span class='TxtNegro'>    DeleteObject(BmpFondo);</span></div><div l=154><span class='TxtNegro'>    DeleteDC(BufferFondo);</span></div><div l=155><span class='TxtNegro'>    SelectObject(BufferVentana, ViejoVentana);</span></div><div l=156><span class='TxtNegro'>    DeleteObject(BmpVentana);</span></div><div l=157><span class='TxtNegro'>    DeleteDC(BufferVentana);</span></div><div l=158><span class='TxtNegro'>}</span></div></pre></div>